
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>URLParser &#8212; Webware for Python 3 3.0.0b0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="next" title="WSGIStreamOut" href="wsgistreamout.html" />
    <link rel="prev" title="UnknownFileTypeServlet" href="unknownfiletypeservlet.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-URLParser">
<span id="urlparser"></span><h1>URLParser<a class="headerlink" href="#module-URLParser" title="Permalink to this headline">¶</a></h1>
<p>URLParser</p>
<p>URL parsing is done through objects which are subclasses of the <cite>URLParser</cite>
class. <cite>Application</cite> delegates most of the URL parsing to these objects.</p>
<p>Application has a single “root” URL parser, which is used to parse all URLs.
This parser then can pass the request on to other parsers, usually taking off
parts of the URL with each step.</p>
<p>This root parser is generally <cite>ContextParser</cite>, which is instantiated and set
up by <cite>Application</cite> (accessible through <cite>Application.rootURLParser</cite>).</p>
<dl class="class">
<dt id="URLParser.ContextParser">
<em class="property">class </em><code class="sig-prename descclassname">URLParser.</code><code class="sig-name descname">ContextParser</code><span class="sig-paren">(</span><em class="sig-param">app</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.ContextParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#URLParser.URLParser" title="URLParser.URLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLParser.URLParser</span></code></a></p>
<p>Find the context of a request.</p>
<p>ContextParser uses the <code class="docutils literal notranslate"><span class="pre">Application.config</span></code> context settings to find
the context of the request.  It then passes the request to a FileParser
rooted in the context path.</p>
<p>The context is the first element of the URL, or if no context matches
that then it is the <code class="docutils literal notranslate"><span class="pre">default</span></code> context (and the entire URL is passed
to the default context’s FileParser).</p>
<p>There is generally only one ContextParser, which can be found as
<code class="docutils literal notranslate"><span class="pre">application.rootURLParser()</span></code>.</p>
<p>Create ContextParser.</p>
<p>ContextParser is usually created by Application, which
passes all requests to it.</p>
<p>In __init__ we take the <code class="docutils literal notranslate"><span class="pre">Contexts</span></code> setting from
Application.config and parse it slightly.</p>
<dl class="method">
<dt id="URLParser.ContextParser.absContextPath">
<code class="sig-name descname">absContextPath</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.ContextParser.absContextPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Get absolute context path.</p>
<p>Resolves relative paths, which are assumed to be relative to the
Application’s serverSidePath (the working directory).</p>
</dd></dl>

<dl class="method">
<dt id="URLParser.ContextParser.addContext">
<code class="sig-name descname">addContext</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.ContextParser.addContext" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a context to the system.</p>
<p>The context will be imported as a package, going by <cite>name</cite>,
from the given directory path. The directory doesn’t have to match
the context name.</p>
</dd></dl>

<dl class="method">
<dt id="URLParser.ContextParser.findServletForTransaction">
<code class="sig-name descname">findServletForTransaction</code><span class="sig-paren">(</span><em class="sig-param">trans</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.ContextParser.findServletForTransaction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a servlet for the transaction.</p>
<p>This is the top-level entry point, below it <cite>parse</cite> is used.</p>
</dd></dl>

<dl class="method">
<dt id="URLParser.ContextParser.parse">
<code class="sig-name descname">parse</code><span class="sig-paren">(</span><em class="sig-param">trans</em>, <em class="sig-param">requestPath</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.ContextParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse request.</p>
<p>Get the context name, and dispatch to a FileParser rooted
in the context’s path.</p>
<p>The context name and file path are stored in the request (accessible
through <cite>Request.serverSidePath</cite> and <cite>Request.contextName</cite>).</p>
</dd></dl>

<dl class="method">
<dt id="URLParser.ContextParser.resolveDefaultContext">
<code class="sig-name descname">resolveDefaultContext</code><span class="sig-paren">(</span><em class="sig-param">dest</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.ContextParser.resolveDefaultContext" title="Permalink to this definition">¶</a></dt>
<dd><p>Find default context.</p>
<p>Figure out if the default context refers to an existing context,
the same directory as an existing context, or a unique directory.</p>
<p>Returns the name of the context that the default context refers to,
or ‘default’ if the default context is unique.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="URLParser.ServletFactoryManagerClass">
<em class="property">class </em><code class="sig-prename descclassname">URLParser.</code><code class="sig-name descname">ServletFactoryManagerClass</code><a class="headerlink" href="#URLParser.ServletFactoryManagerClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Manage servlet factories.</p>
<p>This singleton (called <cite>ServletFactoryManager</cite>) collects and manages
all the servlet factories that are installed.</p>
<p>See <cite>addServletFactory</cite> for adding new factories, and <cite>servletForFile</cite>
for getting the factories back.</p>
<dl class="method">
<dt id="URLParser.ServletFactoryManagerClass.addServletFactory">
<code class="sig-name descname">addServletFactory</code><span class="sig-paren">(</span><em class="sig-param">factory</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.ServletFactoryManagerClass.addServletFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new servlet factory.</p>
<p>Servlet factories can add themselves with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ServletFactoryManager</span><span class="o">.</span><span class="n">addServletFactory</span><span class="p">(</span><span class="n">factory</span><span class="p">)</span>
</pre></div>
</div>
<p>The factory must have an <cite>extensions</cite> method, which should
return a list of extensions that the factory handles (like
<code class="docutils literal notranslate"><span class="pre">['.ht']</span></code>).  The special extension <code class="docutils literal notranslate"><span class="pre">.*</span></code> will match any
file if no other factory is found.  See <cite>ServletFactory</cite>
for more information.</p>
</dd></dl>

<dl class="method">
<dt id="URLParser.ServletFactoryManagerClass.factoryForFile">
<code class="sig-name descname">factoryForFile</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.ServletFactoryManagerClass.factoryForFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a factory for a filename.</p>
</dd></dl>

<dl class="method">
<dt id="URLParser.ServletFactoryManagerClass.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.ServletFactoryManagerClass.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="URLParser.ServletFactoryManagerClass.servletForFile">
<code class="sig-name descname">servletForFile</code><span class="sig-paren">(</span><em class="sig-param">trans</em>, <em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.ServletFactoryManagerClass.servletForFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a servlet for a filename and transaction.</p>
<p>Uses <cite>factoryForFile</cite> to find the factory, which
creates the servlet.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="URLParser.URLParameterParser">
<em class="property">class </em><code class="sig-prename descclassname">URLParser.</code><code class="sig-name descname">URLParameterParser</code><span class="sig-paren">(</span><em class="sig-param">fileParser=None</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.URLParameterParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#URLParser.URLParser" title="URLParser.URLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLParser.URLParser</span></code></a></p>
<p>Strips named parameters out of the URL.</p>
<p>E.g. in <code class="docutils literal notranslate"><span class="pre">/path/SID=123/etc</span></code> the <code class="docutils literal notranslate"><span class="pre">SID=123</span></code> will be removed from the URL,
and a field will be set in the request (so long as no field by that name
already exists – if a field does exist the variable is thrown away).
These are put in the place of GET or POST variables.</p>
<p>It should be put in an __init__, like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">URLParser</span> <span class="kn">import</span> <span class="n">URLParameterParser</span>
<span class="n">urlParserHook</span> <span class="o">=</span> <span class="n">URLParameterParser</span><span class="p">()</span>
</pre></div>
</div>
<p>Or (slightly less efficient):</p>
<blockquote>
<div><p>from URLParser import URLParameterParser as SubParser</p>
</div></blockquote>
<dl class="method">
<dt id="URLParser.URLParameterParser.findServletForTransaction">
<code class="sig-name descname">findServletForTransaction</code><span class="sig-paren">(</span><em class="sig-param">trans</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.URLParameterParser.findServletForTransaction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a servlet for the transaction.</p>
<p>This is the top-level entry point, below it <cite>parse</cite> is used.</p>
</dd></dl>

<dl class="method">
<dt id="URLParser.URLParameterParser.parse">
<code class="sig-name descname">parse</code><span class="sig-paren">(</span><em class="sig-param">trans</em>, <em class="sig-param">requestPath</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.URLParameterParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Delegates to <cite>parseHook</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="URLParser.URLParameterParser.parseHook">
<em class="property">static </em><code class="sig-name descname">parseHook</code><span class="sig-paren">(</span><em class="sig-param">trans</em>, <em class="sig-param">requestPath</em>, <em class="sig-param">hook</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.URLParameterParser.parseHook" title="Permalink to this definition">¶</a></dt>
<dd><p>Munges the path.</p>
<p>The <cite>hook</cite> is the FileParser object that originally called this –
we just want to strip stuff out of the URL and then give it back to
the FileParser instance, which can actually find the servlet.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="URLParser.URLParser">
<em class="property">class </em><code class="sig-prename descclassname">URLParser.</code><code class="sig-name descname">URLParser</code><a class="headerlink" href="#URLParser.URLParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>URLParser is the base class for all URL parsers.</p>
<p>Though its functionality is sparse, it may be expanded in the future.
Subclasses should implement a <cite>parse</cite> method, and may also want to
implement an <cite>__init__</cite> method with arguments that control how the
parser works (for instance, passing a starting path for the parser)</p>
<p>The <cite>parse</cite> method is where most of the work is done. It takes two
arguments – the transaction and the portion of the URL that is still to
be parsed. The transaction may (and usually is) modified along the way.
The URL is passed through so that you can take pieces off the front,
and then pass the reduced URL to another parser. The method should return
a servlet (never None).</p>
<p>If you cannot find a servlet, or some other (somewhat) expected error
occurs, you should raise an exception. HTTPNotFound probably being the
most interesting.</p>
<dl class="method">
<dt id="URLParser.URLParser.findServletForTransaction">
<code class="sig-name descname">findServletForTransaction</code><span class="sig-paren">(</span><em class="sig-param">trans</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.URLParser.findServletForTransaction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a servlet for the transaction.</p>
<p>This is the top-level entry point, below it <cite>parse</cite> is used.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="URLParser._FileParser">
<em class="property">class </em><code class="sig-prename descclassname">URLParser.</code><code class="sig-name descname">_FileParser</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser._FileParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#URLParser.URLParser" title="URLParser.URLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLParser.URLParser</span></code></a></p>
<p>Parse requests to the filesystem.</p>
<p>FileParser dispatches to servlets in the filesystem, as well as providing
hooks to override the FileParser.</p>
<p>FileParser objects are threadsafe. A factory function is used to cache
FileParser instances, so for any one path only a single FileParser instance
will exist.  The <cite>_FileParser</cite> class is the real class, and <cite>FileParser</cite> is
a factory that either returns an existent _FileParser object, or creates a
new one if none exists.</p>
<p>FileParser uses several settings from <code class="docutils literal notranslate"><span class="pre">Application.config</span></code>, which are
persistent over the life of the application. These are set up in the
function <cite>initApp</cite>, as class variables. They cannot be set when the module
is loaded, because the Application is not yet set up, so <cite>initApp</cite> is
called in <cite>Application.__init__</cite>.</p>
<p>Create a FileParser.</p>
<p>Each parsed directory has a FileParser instance associated with it
(<code class="docutils literal notranslate"><span class="pre">self._path</span></code>).</p>
<dl class="attribute">
<dt id="URLParser._FileParser._byteCodeExtensions">
<code class="sig-name descname">_byteCodeExtensions</code><em class="property"> = ['opt-2.pyc']</em><a class="headerlink" href="#URLParser._FileParser._byteCodeExtensions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="URLParser._FileParser.filenamesForBaseName">
<code class="sig-name descname">filenamesForBaseName</code><span class="sig-paren">(</span><em class="sig-param">baseName</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser._FileParser.filenamesForBaseName" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all files for a given base name.</p>
<p>Given a path, like <code class="docutils literal notranslate"><span class="pre">/a/b/c</span></code>, searches for files in <code class="docutils literal notranslate"><span class="pre">/a/b</span></code>
that start with <code class="docutils literal notranslate"><span class="pre">c</span></code>.  The final name may include an extension,
which is less ambiguous; though if you ask for file.html,
and file.html.py exists, that file will be returned.</p>
<p>The files are filtered according to the settings <code class="docutils literal notranslate"><span class="pre">FilesToHide</span></code>,
<code class="docutils literal notranslate"><span class="pre">FilesToServe</span></code>, <code class="docutils literal notranslate"><span class="pre">ExtensionsToIgnore</span></code> and <code class="docutils literal notranslate"><span class="pre">ExtensionsToServe</span></code>.
See the shouldServeFile() method for details on these settings.</p>
<p>All files that start with the given base name are returned
as a list. When the base name itself is part of the list or
when extensions are prioritized and such an extension is found
in the list, then the list will be reduced to only that entry.</p>
<p>Some settings are used to control the prioritization of filenames.
All settings are in <code class="docutils literal notranslate"><span class="pre">Application.config</span></code>:</p>
<dl class="simple">
<dt>UseCascadingExtensions:</dt><dd><p>If true, then extensions will be prioritized.  So if
extension <code class="docutils literal notranslate"><span class="pre">.tmpl</span></code> shows up in ExtensionCascadeOrder
before <code class="docutils literal notranslate"><span class="pre">.html</span></code>, then even if filenames with both
extensions exist, only the .tmpl file will be returned.</p>
</dd>
<dt>ExtensionCascadeOrder:</dt><dd><p>A list of extensions, ordered by priority.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="URLParser._FileParser.findServletForTransaction">
<code class="sig-name descname">findServletForTransaction</code><span class="sig-paren">(</span><em class="sig-param">trans</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser._FileParser.findServletForTransaction" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a servlet for the transaction.</p>
<p>This is the top-level entry point, below it <cite>parse</cite> is used.</p>
</dd></dl>

<dl class="method">
<dt id="URLParser._FileParser.initModule">
<code class="sig-name descname">initModule</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#URLParser._FileParser.initModule" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the __init__ module object for this FileParser’s directory.</p>
</dd></dl>

<dl class="method">
<dt id="URLParser._FileParser.parse">
<code class="sig-name descname">parse</code><span class="sig-paren">(</span><em class="sig-param">trans</em>, <em class="sig-param">requestPath</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser._FileParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the servlet.</p>
<p>__init__ files will be used for various hooks
(see <cite>parseInit</cite> for more).</p>
<p>If the next part of the URL is a directory, it calls
<code class="docutils literal notranslate"><span class="pre">FileParser(dirPath).parse(trans,</span> <span class="pre">restOfPath)</span></code> where <code class="docutils literal notranslate"><span class="pre">restOfPath</span></code>
is <cite>requestPath</cite> with the first section of the path removed (the part
of the path that this FileParser just handled).</p>
<p>This uses <cite>fileNamesForBaseName</cite> to find files in its directory.
That function has several functions to define what files are ignored,
hidden, etc.  See its documentation for more information.</p>
</dd></dl>

<dl class="method">
<dt id="URLParser._FileParser.parseIndex">
<code class="sig-name descname">parseIndex</code><span class="sig-paren">(</span><em class="sig-param">trans</em>, <em class="sig-param">requestPath</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser._FileParser.parseIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return index servlet.</p>
<p>Return the servlet for a directory index (i.e., <code class="docutils literal notranslate"><span class="pre">Main</span></code> or
<code class="docutils literal notranslate"><span class="pre">index</span></code>).  When <cite>parse</cite> encounters a directory and there’s nothing
left in the URL, or when there is something left and no file matches
it, then it will try <cite>parseIndex</cite> to see if there’s an index file.</p>
<p>That means that if <code class="docutils literal notranslate"><span class="pre">/a/b/c</span></code> is requested, and in <code class="docutils literal notranslate"><span class="pre">/a</span></code> there’s no
file or directory matching <code class="docutils literal notranslate"><span class="pre">b</span></code>, then it’ll look for an index file
(like <code class="docutils literal notranslate"><span class="pre">Main.py</span></code>), and that servlet will be returned. In fact, if
no <code class="docutils literal notranslate"><span class="pre">a</span></code> was found, and the default context had an index (like
<code class="docutils literal notranslate"><span class="pre">index.html</span></code>) then that would be called with <code class="docutils literal notranslate"><span class="pre">/a/b/c</span></code> as
<cite>HTTPRequest.extraURLPath</cite>.  If you don’t want that to occur, you
should raise an HTTPNotFound in your no-extra-url-path-taking servlets.</p>
<p>The directory names are based off the <code class="docutils literal notranslate"><span class="pre">Application.config</span></code> setting
<code class="docutils literal notranslate"><span class="pre">DirectoryFile</span></code>, which is a list of base names, by default
<code class="docutils literal notranslate"><span class="pre">[&quot;Main&quot;,</span> <span class="pre">&quot;index&quot;,</span> <span class="pre">&quot;main&quot;,</span> <span class="pre">&quot;Index&quot;]</span></code>, which are searched in order.
A file with any extension is allowed, so the index can be an HTML file,
a PSP file, a Python servlet, etc.</p>
</dd></dl>

<dl class="method">
<dt id="URLParser._FileParser.parseInit">
<code class="sig-name descname">parseInit</code><span class="sig-paren">(</span><em class="sig-param">trans</em>, <em class="sig-param">requestPath</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser._FileParser.parseInit" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse the __init__ file.</p>
<p>Returns the resulting servlet, or None if no __init__ hooks were found.</p>
<p>Hooks are put in by defining special functions or objects in your
__init__, with specific names:</p>
<dl>
<dt><cite>urlTransactionHook</cite>:</dt><dd><p>A function that takes one argument (the transaction).
The return value from the function is ignored.  You
can modify the transaction with this function, though.</p>
</dd>
<dt><cite>urlRedirect</cite>:</dt><dd><p>A dictionary.  Keys in the dictionary are source
URLs, the value is the path to redirect to, or a
<cite>URLParser</cite> object to which the transaction should
be delegated.</p>
<p>For example, if the URL is <code class="docutils literal notranslate"><span class="pre">/a/b/c</span></code>, and we’ve already
parsed <code class="docutils literal notranslate"><span class="pre">/a</span></code> and are looking for <code class="docutils literal notranslate"><span class="pre">b/c</span></code>, and we fine
<cite>urlRedirect`</cite> in a.__init__, then we’ll look for a key
<code class="docutils literal notranslate"><span class="pre">b</span></code> in the dictionary.  The value will be a directory
we should continue to (say, <code class="docutils literal notranslate"><span class="pre">/destpath/</span></code>).  We’ll
then look for <code class="docutils literal notranslate"><span class="pre">c</span></code> in <code class="docutils literal notranslate"><span class="pre">destpath</span></code>.</p>
<p>If a key ‘’ (empty string) is in the dictionary, then
if no more specific key is found all requests will
be redirected to that path.</p>
<p>Instead of a string giving a path to redirect to, you
can also give a URLParser object, so that some portions
of the path are delegated to different parsers.</p>
<p>If no matching key is found, and there is no ‘’ key,
then parsing goes on as usual.</p>
</dd>
<dt><cite>SubParser</cite>:</dt><dd><p>This should be a class object.  It will be instantiated,
and then <cite>parse</cite> will be called with it, delegating to
this instance.  When instantiated, it will be passed
<em>this</em> FileParser instance; the parser can use this to
return control back to the FileParser after doing whatever
it wants to do.</p>
<p>You may want to use a line like this to handle the names:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ParserX</span> <span class="kn">import</span> <span class="n">ParserX</span> <span class="k">as</span> <span class="n">SubParser</span>
</pre></div>
</div>
</dd>
<dt><cite>urlParser</cite>:</dt><dd><p>This should be an already instantiated URLParser-like
object.  <cite>parse(trans, requestPath)</cite> will be called
on this instance.</p>
</dd>
<dt><cite>urlParserHook</cite>:</dt><dd><p>Like <cite>urlParser</cite>, except the method
<cite>parseHook(trans, requestPath, fileParser)</cite> will
be called, where fileParser is this FileParser instance.</p>
</dd>
<dt><cite>urlJoins</cite>:</dt><dd><p>Either a single path, or a list of paths.  You can also
use URLParser objects, like with <cite>urlRedirect</cite>.</p>
<p>Each of these paths (or parsers) will be tried in
order.  If it raises HTTPNotFound, then the next path
will be tried, ending with the current path.</p>
<p>Paths are relative to the current directory.  If you
don’t want the current directory to be a last resort,
you can include ‘.’ in the joins.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="URLParser._FileParser.shouldServeFile">
<code class="sig-name descname">shouldServeFile</code><span class="sig-paren">(</span><em class="sig-param">filename</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser._FileParser.shouldServeFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the file with the given filename should be served.</p>
<p>Some settings are used to control the filtering of filenames.
All settings are in <code class="docutils literal notranslate"><span class="pre">Application.config</span></code>:</p>
<dl class="simple">
<dt>FilesToHide:</dt><dd><p>These files will be ignored, and even given a full
extension will not be used.  Takes a glob.</p>
</dd>
<dt>FilesToServe:</dt><dd><p>If set, <em>only</em> files matching these globs will be
served, all other files will be ignored.</p>
</dd>
<dt>ExtensionsToIgnore:</dt><dd><p>Files with these extensions will be ignored, but if a
complete filename (with extension) is given the file
<em>will</em> be served (unlike FilesToHide).  Extensions are
in the form <code class="docutils literal notranslate"><span class="pre">&quot;.py&quot;</span></code></p>
</dd>
<dt>ExtensionsToServe:</dt><dd><p>If set, only files with these extensions will be
served.  Like FilesToServe, only doesn’t use globs.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="URLParser.application">
<code class="sig-prename descclassname">URLParser.</code><code class="sig-name descname">application</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.application" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the global Application.</p>
</dd></dl>

<dl class="function">
<dt id="URLParser.initApp">
<code class="sig-prename descclassname">URLParser.</code><code class="sig-name descname">initApp</code><span class="sig-paren">(</span><em class="sig-param">app</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.initApp" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the application.</p>
<p>Installs the proper servlet factories, and gets some settings from
Application.config. Also saves the application in _globalApplication
for future calls to the application() function.</p>
<p>This needs to be called before any of the URLParser-derived classes
are instantiated.</p>
</dd></dl>

<dl class="function">
<dt id="URLParser.initParser">
<code class="sig-prename descclassname">URLParser.</code><code class="sig-name descname">initParser</code><span class="sig-paren">(</span><em class="sig-param">app</em><span class="sig-paren">)</span><a class="headerlink" href="#URLParser.initParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the FileParser Class.</p>
</dd></dl>

</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Webware for Python 3</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changes.html">List of Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../migrate.html">Migration Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../copyright.html">Copyright and License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial.html">Beginner Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../appdev.html">Application Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../config.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../deploy.html">Deployment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plugins.html">Plug-ins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../style.html">Style Guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../psp.html">PSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../userkit.html">UserKit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../taskkit.html">TaskKit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../webutils.html">WebUtils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../miscutils.html">MiscUtils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../testing.html">Testing</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Core Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../psp/index.html">PSP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../userkit/index.html">UserKit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../taskkit/index.html">TaskKit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../webutils/index.html">WebUtils</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscutils/index.html">MiscUtils</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">API Reference</a><ul>
  <li><a href="index.html">Core Classes</a><ul>
      <li>Previous: <a href="unknownfiletypeservlet.html" title="previous chapter">UnknownFileTypeServlet</a></li>
      <li>Next: <a href="wsgistreamout.html" title="next chapter">WSGIStreamOut</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Christoph Zwerschke et al.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/ref/core/urlparser.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>